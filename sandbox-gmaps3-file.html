<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<!-- Conditional commenting for non-IE browsers -->
		<!--[if !IE]><!-->
			<link rel="stylesheet" type="text/css" href="index.css" />
		<!--<![endif]-->
	<!-- Conditional commenting for IE 6.x -->
		<!--[if IE]>
			<link rel="stylesheet" type="text/css" href="index.ie.css" />
		<![endif]-->
</head>
<title>Wicket - Lightweight Javascript for WKT [Sandbox]</title>
<script async defer src="https://maps.googleapis.com/maps/api/js?libraries=drawing&key=AIzaSyCkSwtWO6SLwcelZj8jUomeTotr0RcuEJE" type="text/javascript"></script>
<script src="wicket.js" type="text/javascript"></script>
<script src="wicket-gmap3.js" type="text/javascript"></script>
<script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=fetch,requestAnimationFrame,Element.prototype.classList,URL"></script>
<script src="https://unpkg.com/jsts@2.0.2/dist/jsts.min.js"></script>

<script type="text/javascript">

var app = (function () {
	return {
		features: [],
		/**
		 * Clears the map contents.
		 */
		clearMap: function () {
			var i;

			for (i in this.features) {
				if (this.features.hasOwnProperty(i)) {
					this.features[i].setMap(null);
				}
			}
			this.features.length = 0;
		},

		handleFileSelect: function(evt) {
			var files = evt.target.files; // FileList object
			let promises = [];
			for (let file of files) {
				let filePromise = new Promise(resolve => {
					let reader = new FileReader();
					reader.readAsText(file);
					reader.onload = () => resolve(reader.result);
				});
				promises.push(filePromise);
			}
			Promise.all(promises).then(textList => {
				// textList will be an array containing the contents of the files
				var wreader = new jsts.io.WKTReader()
				var wwriter = new jsts.io.WKTWriter()
				var union
				for (var i = 0, objText ; objText = textList[i]; i++) {
					if (app.isCircle(objText)) {
						app.mapIt(app.loadCircle(objText));
						continue
					}
					let s1 = wreader.read(objText)
					if (union == null) {
						union = s1
						continue
					}
					union = s1.union(union)
				}
				app.mapIt(app.loadObj(wwriter.write(union)));
			});
		},

		isCircle: function(objText) {
			return objText.substring(0, 6).toLowerCase() == "circle"
		},
		loadCircle: function(objText) {
			console.log("loadCircle", objText);
			objText = objText.substring(6); // remove word circle
			objText = objText.replace('(', '[').replace(')', ']');
			// now objText should be a json array
			var arr = JSON.parse(objText);
			var obj = new google.maps.Circle({
				center: {lat: arr[0], lng: arr[1]},
				radius: arr[2],
				strokeColor: '#FF0000',
				strokeOpacity: 0.8,
				strokeWeight: 2,
				fillColor: '#FF0000',
				fillOpacity: 0.35,
				map: this.gmap
			});
			obj.type = "circle"
			return obj
		},
		loadObj: function(objText) {
			console.log("loadObj");
			var wkt = new Wkt.Wkt();
			try { // Catch any malformed WKT strings
				wkt.read(objText);
			} catch (e1) {
				try {
					wkt.read(objText.replace('\n', '').replace('\r', '').replace('\t', ''));
				} catch (e2) {
					if (e2.name === 'WKTError') {
						alert('Wicket could not understand the WKT string you entered. Check that you have parentheses balanced, and try removing tabs and newline characters.');
						return;
					}
				}
			}
			var obj = wkt.toObject(this.gmap.defaults); // Make an object
			obj.type = wkt.type
			console.log("Loaded WKT object", obj.type)
			return obj
		},

		/**
		 * Maps the current contents of the textarea.
		 * @return  {Object}    Some sort of geometry object
		 */
		mapIt: function (obj) {
			if (obj.type != "circle") {
				// Add listeners for overlay editing events
				if (!Wkt.isArray(obj) && obj.type !== 'point') {
				} else {
					if (obj.setEditable) {obj.setEditable(false);}
				}
			}

			var bounds = new google.maps.LatLngBounds();

			if (obj.type != "circle" && Wkt.isArray(obj)) { // Distinguish multigeometries (Arrays) from objects
				for (i in obj) {
					if (obj.hasOwnProperty(i) && !Wkt.isArray(obj[i])) {
						obj[i].setMap(this.gmap);
						this.features.push(obj[i]);

						if(obj.type === 'point' || obj.type === 'multipoint')
							bounds.extend(obj[i].getPosition());
						else
							obj[i].getPath().forEach(function(element,index){bounds.extend(element)});
					}
				}

				this.features = this.features.concat(obj);
			} else {
				obj.setMap(this.gmap); // Add it to the map
				this.features.push(obj);

				if(obj.type === 'point' || obj.type === 'multipoint') {
					bounds.extend(obj.getPosition());
				} else if(obj.type === 'circle') {
				} else {
					obj.getPath().forEach(function(element,index){bounds.extend(element)});
				}
			}

			// Pan the map to the feature
			this.gmap.fitBounds(bounds);

			return obj;
		},
		/**
		 * Application entry point.
		 * @return  {<google.maps.Map>} The Google Maps API instance
		 */
		init: function () {
			var gmap;

			gmap = new google.maps.Map(document.getElementById('canvas'), {
				center: new google.maps.LatLng(30, 10),
				defaults: {
					icon: 'red_dot.png',
					shadow: 'dot_shadow.png',
					editable: true,
					strokeColor: '#990000',
					fillColor: '#EEFFCC',
					fillOpacity: 0.6
				},
				disableDefaultUI: true,
				mapTypeControl: true,
				mapTypeId: google.maps.MapTypeId.ROADMAP,
				mapTypeControlOptions: {
					position: google.maps.ControlPosition.TOP_LEFT,
					style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
				},
				panControl: false,
				streetViewControl: false,
				zoom: 2,
				zoomControl: true,
				zoomControlOptions: {
					position: google.maps.ControlPosition.LEFT_TOP,
					style: google.maps.ZoomControlStyle.SMALL
				}
			});

			google.maps.event.addListener(gmap, 'tilesloaded', function () {
				if (!this.loaded) {
					this.loaded = true;
					// app.mapIt();
				}
			});

			gmap.drawingManager = new google.maps.drawing.DrawingManager({
				drawingControlOptions: {
					position: google.maps.ControlPosition.TOP_CENTER,
					drawingModes: [
						google.maps.drawing.OverlayType.MARKER,
						google.maps.drawing.OverlayType.POLYLINE,
						google.maps.drawing.OverlayType.POLYGON,
						google.maps.drawing.OverlayType.RECTANGLE
					]
				},
				markerOptions: gmap.defaults,
				polygonOptions: gmap.defaults,
				polylineOptions: gmap.defaults,
				rectangleOptions: gmap.defaults
			});
			gmap.drawingManager.setMap(gmap);

			document.getElementById('files').addEventListener('change', app.handleFileSelect, false);
			google.maps.event.addListener(gmap.drawingManager, 'overlaycomplete', function (event) {
				var wkt;

				app.clearMap();

				// Set the drawing mode to "pan" (the hand) so users can immediately edit
				this.setDrawingMode(null);

				app.features.push(event.overlay);
				wkt = new Wkt.Wkt();
				wkt.fromObject(event.overlay);
				// document.getElementById('wkt').value = wkt.write();
				});

			return gmap;
		}
	};
}()); // Execute immediately

</script>
<body onload="app.gmap=app.init();">
	<div id="ribbon">
		<div class="wrapper">
			<div id="canvas">
			</div>
			<div id="controls">
				<div class="title">
					<div class="brand">Wicket</div>
				</div>
				<div class="text">
					Wicket is a lightweight Javascript library that reads and writes <a href="http://en.wikipedia.org/wiki/Well-known_text#Geometric_objects" target="_blaknk">Well-Known Text (WKT)</a> strings. It can also be extended to parse and to create geometric objects from various mapping frameworks, such as <a href="http://http://leafletjs.com/" target="_blank">Leaflet</a>, the ESRI ArcGIS JavaScript API, and the Google Maps API.
				</div>
				<div id="form">
					<input type="file" id="files" name="files[]" multiple />
					<!-- <input type="submit" id="submit" value="Map It!" onclick="app.clearMap();app.mapIt();" /> -->
				</div>
			</div>
		</div>
	</div>
</body>
</html>
