<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<!-- Conditional commenting for non-IE browsers -->
		<!--[if !IE]><!-->
			<link rel="stylesheet" type="text/css" href="index.css" />
		<!--<![endif]-->
	<!-- Conditional commenting for IE 6.x -->
		<!--[if IE]>
			<link rel="stylesheet" type="text/css" href="index.ie.css" />
		<![endif]-->
</head>
<title>Wicket - Lightweight Javascript for WKT [Sandbox]</title>
<script async defer src="https://maps.googleapis.com/maps/api/js?libraries=drawing&key=AIzaSyCkSwtWO6SLwcelZj8jUomeTotr0RcuEJE" type="text/javascript"></script>
<script src="wicket.js" type="text/javascript"></script>
<script src="wicket-gmap3.js" type="text/javascript"></script>
<script type="text/javascript">

var app = (function () {
	return {
		features: [],
		/**
		 * Clears the map contents.
		 */
		clearMap: function () {
			var i;

			for (i in this.features) {
				if (this.features.hasOwnProperty(i)) {
					this.features[i].setMap(null);
				}
			}
			this.features.length = 0;
		},
 
		handleFileSelect: function(evt) {
			var files = evt.target.files; // FileList object

			// files is a FileList of File objects. List some properties.
			var output = [];
			for (var i = 0, f; f = files[i]; i++) {
				var reader = new FileReader();
				reader.onload = function(){
					app.mapIt(reader.result);
				};
				reader.readAsText(f);
			}
		},

		/**
		 * Maps the current contents of the textarea.
		 * @return  {Object}    Some sort of geometry object
		 */
		mapIt: function (wktText) {
			var obj, wkt;
			wkt = new Wkt.Wkt();
			try { // Catch any malformed WKT strings
				wkt.read(wktText);
			} catch (e1) {
				try {
					wkt.read(wktText.replace('\n', '').replace('\r', '').replace('\t', ''));
				} catch (e2) {
					if (e2.name === 'WKTError') {
						alert('Wicket could not understand the WKT string you entered. Check that you have parentheses balanced, and try removing tabs and newline characters.');
						return;
					}
				}
			}

			obj = wkt.toObject(this.gmap.defaults); // Make an object

			// Add listeners for overlay editing events
			if (!Wkt.isArray(obj) && wkt.type !== 'point') {
				// New vertex is inserted
				google.maps.event.addListener(obj.getPath(), 'insert_at', function (n) {
					app.updateText();
				});
				// Existing vertex is removed (insertion is undone)
				google.maps.event.addListener(obj.getPath(), 'remove_at', function (n) {
					app.updateText();
				});
				// Existing vertex is moved (set elsewhere)
				google.maps.event.addListener(obj.getPath(), 'set_at', function (n) {
					app.updateText();
				});
			} else {
				if (obj.setEditable) {obj.setEditable(false);}
			}

			var bounds = new google.maps.LatLngBounds();

			if (Wkt.isArray(obj)) { // Distinguish multigeometries (Arrays) from objects
				for (i in obj) {
					if (obj.hasOwnProperty(i) && !Wkt.isArray(obj[i])) {
						obj[i].setMap(this.gmap);
						this.features.push(obj[i]);

						if(wkt.type === 'point' || wkt.type === 'multipoint')
							bounds.extend(obj[i].getPosition());
						else
							obj[i].getPath().forEach(function(element,index){bounds.extend(element)});
					}
				}

				this.features = this.features.concat(obj);
			} else {
				obj.setMap(this.gmap); // Add it to the map
				this.features.push(obj);

				if(wkt.type === 'point' || wkt.type === 'multipoint')
					bounds.extend(obj.getPosition());
				else
					obj.getPath().forEach(function(element,index){bounds.extend(element)});
			}

			// Pan the map to the feature
			this.gmap.fitBounds(bounds);

			return obj;
		},
		/**
		 * Application entry point.
		 * @return  {<google.maps.Map>} The Google Maps API instance
		 */
		init: function () {
			var gmap;

			gmap = new google.maps.Map(document.getElementById('canvas'), {
				center: new google.maps.LatLng(30, 10),
				defaults: {
					icon: 'red_dot.png',
					shadow: 'dot_shadow.png',
					editable: true,
					strokeColor: '#990000',
					fillColor: '#EEFFCC',
					fillOpacity: 0.6
				},
				disableDefaultUI: true,
				mapTypeControl: true,
				mapTypeId: google.maps.MapTypeId.ROADMAP,
				mapTypeControlOptions: {
					position: google.maps.ControlPosition.TOP_LEFT,
					style: google.maps.MapTypeControlStyle.DROPDOWN_MENU
				},
				panControl: false,
				streetViewControl: false,
				zoom: 2,
				zoomControl: true,
				zoomControlOptions: {
					position: google.maps.ControlPosition.LEFT_TOP,
					style: google.maps.ZoomControlStyle.SMALL
				}
			});

			google.maps.event.addListener(gmap, 'tilesloaded', function () {
				if (!this.loaded) {
					this.loaded = true;
					// app.mapIt();
				}
			});

			gmap.drawingManager = new google.maps.drawing.DrawingManager({
				drawingControlOptions: {
					position: google.maps.ControlPosition.TOP_CENTER,
					drawingModes: [
						google.maps.drawing.OverlayType.MARKER,
						google.maps.drawing.OverlayType.POLYLINE,
						google.maps.drawing.OverlayType.POLYGON,
						google.maps.drawing.OverlayType.RECTANGLE
					]
				},
				markerOptions: gmap.defaults,
				polygonOptions: gmap.defaults,
				polylineOptions: gmap.defaults,
				rectangleOptions: gmap.defaults
			});
			gmap.drawingManager.setMap(gmap);

			document.getElementById('files').addEventListener('change', app.handleFileSelect, false);
			google.maps.event.addListener(gmap.drawingManager, 'overlaycomplete', function (event) {
				var wkt;

				app.clearMap();

				// Set the drawing mode to "pan" (the hand) so users can immediately edit
				this.setDrawingMode(null);

				// Polygon drawn
				if (event.type === google.maps.drawing.OverlayType.POLYGON || event.type === google.maps.drawing.OverlayType.POLYLINE) {
					// New vertex is inserted
					google.maps.event.addListener(event.overlay.getPath(), 'insert_at', function (n) {
						app.updateText();
					});

					// Existing vertex is removed (insertion is undone)
					google.maps.event.addListener(event.overlay.getPath(), 'remove_at', function (n) {
						app.updateText();
					});

					// Existing vertex is moved (set elsewhere)
					google.maps.event.addListener(event.overlay.getPath(), 'set_at', function (n) {
						app.updateText();
					});
				} else if (event.type === google.maps.drawing.OverlayType.RECTANGLE) { // Rectangle drawn
					// Listen for the 'bounds_changed' event and update the geometry
					google.maps.event.addListener(event.overlay, 'bounds_changed', function () {
						app.updateText();
					});
				}

				app.features.push(event.overlay);
				wkt = new Wkt.Wkt();
				wkt.fromObject(event.overlay);
				// document.getElementById('wkt').value = wkt.write();
				});

			return gmap;
		}
	};
}()); // Execute immediately

</script>
<body onload="app.gmap=app.init();">
	<div id="ribbon">
		<div class="wrapper">
			<div id="canvas">
			</div>
			<div id="controls">
				<div class="title">
					<div class="brand">Wicket</div>
				</div>
				<div class="text">
					Wicket is a lightweight Javascript library that reads and writes <a href="http://en.wikipedia.org/wiki/Well-known_text#Geometric_objects" target="_blaknk">Well-Known Text (WKT)</a> strings. It can also be extended to parse and to create geometric objects from various mapping frameworks, such as <a href="http://http://leafletjs.com/" target="_blank">Leaflet</a>, the ESRI ArcGIS JavaScript API, and the Google Maps API.
				</div>
				<div id="form">
					<input type="file" id="files" name="files[]" multiple />
					<!-- <input type="submit" id="submit" value="Map It!" onclick="app.clearMap();app.mapIt();" /> -->
				</div>
			</div>
		</div>
	</div>
</body>
</html>
